name: CI

on:
  pull_request:
    branches:
      - staging
      - production
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/production' }}

env:
  TEST_MODE: ${{ vars.TEST_MODE }}
  TEST_E2E_SHORTCIRCUIT: '1'
  IS_PRELAUNCH: 'true'
  EMAIL_TRANSPORT: noop
  ANALYTICS_STORE_IP: 'false'
  NEXT_PUBLIC_ENV: 'ci'
  NEXT_PUBLIC_LOCALES: 'en-de,de-de,fr-fr,nl-nl,it-it'
  NEXT_PUBLIC_DEFAULT_LOCALE: 'de-de'
  NEXT_PUBLIC_ANALYTICS_DISABLED: '1'
  NEXT_PUBLIC_ANALYTICS_DEBUG: '0'
  NEXT_PUBLIC_ALLOW_INDEXING: 'false'
  NEXT_PUBLIC_HCAPTCHA_SITE_KEY: '10000000-ffff-ffff-ffff-000000000001'
  NEXT_PUBLIC_WAITLIST_URGENCY: 'true'
  CSP_MODE: ${{ vars.CSP_MODE }}
  CSP_NONCE_BYTES: ${{ vars.CSP_NONCE_BYTES }}
  COMMIT_SHA: ${{ github.sha }}
  NEXT_PUBLIC_COMMIT_SHA: ${{ github.sha }}
  NEXT_BUILD_DIR: .next

jobs:
  setup:
    name: setup
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: ðŸ”Ž CI Context
        run: |
          echo 'ðŸ”Ž CI Context: NEXT_PUBLIC_LOCALES=${NEXT_PUBLIC_LOCALES}'
          echo 'ðŸ”Ž CI Context: NEXT_PUBLIC_DEFAULT_LOCALE=${NEXT_PUBLIC_DEFAULT_LOCALE}'

      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm ci --include=dev

  lint-and-types:
    name: lint-and-types
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --include=dev

      - name: Lint
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run lint

      - name: Type check
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run typecheck

      - name: Dependency graph policy
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run lint:deps

      - name: Unit tests
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run test:unit

  build:
    name: build
    runs-on: ubuntu-latest
    needs:
      - setup
      - lint-and-types
    timeout-minutes: 30
    outputs:
      has_next: ${{ steps.detect_next_build.outputs.has_next }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm ci --include=dev

      - name: Build Next.js app
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run build

      - name: Detect Next build output
        id: detect_next_build
        run: |
          echo "NEXT_BUILD_DIR=${NEXT_BUILD_DIR}"
          if [ -d "${NEXT_BUILD_DIR}" ]; then
            ls -la "${NEXT_BUILD_DIR}" || true
            count=$(find "${NEXT_BUILD_DIR}" -type f -print | wc -l | tr -d '[:space:]')
            count=${count:-0}
          else
            echo "::notice::Build directory ${NEXT_BUILD_DIR} does not exist"
            count=0
          fi
          echo "NEXT_BUILD_FILE_COUNT=${count}"
          if [ "${count}" -gt 0 ]; then
            echo "Detected Next build artifacts in ${NEXT_BUILD_DIR}"
            echo "has_next=true" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::No build artifacts detected in ${NEXT_BUILD_DIR}"
            echo "has_next=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Next build (if present)
        if: steps.detect_next_build.outputs.has_next == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: next-build
          path: ${{ github.workspace }}/${{ env.NEXT_BUILD_DIR }}
          if-no-files-found: error
          include-hidden-files: true

  e2e:
    name: e2e (csp=${{ matrix.csp_mode }})
    strategy:
      fail-fast: false
      matrix:
        include:
          - csp_mode: report-only
          - csp_mode: strict
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 45
    env:
      CI: true
      NODE_ENV: production
      HOST: ${{ vars.HOST }}
      PORT: ${{ vars.PORT }}
      APP_BASE_URL: ${{ vars.BASE_URL }}
      NEXT_PUBLIC_SITE_URL: ${{ vars.BASE_URL }}
      BASE_URL: ${{ vars.BASE_URL }}
      DEFAULT_LOCALE: ${{ vars.DEFAULT_LOCALE }}
      CSP_MODE: ${{ matrix.csp_mode == 'strict' && 'strict' || vars.CSP_MODE }}
      ANALYTICS_ENABLED: ${{ vars.ANALYTICS_ENABLED }}
      NEXT_PUBLIC_TEST_MODE: ${{ vars.NEXT_PUBLIC_TEST_MODE }}
      TEST_MODE: ${{ vars.TEST_MODE }}
      PLAYWRIGHT_BROWSERS_PATH: ${{ vars.PLAYWRIGHT_BROWSERS_PATH }}
      WAITLIST_CONFIRM_TTL_DAYS: '7'
      HCAPTCHA_SECRET: ${{ secrets.CI_HCAPTCHA_SECRET }}
      FIREBASE_PROJECT_ID: ${{ secrets.CI_FIREBASE_PROJECT_ID }}
      FIREBASE_DB_REGION: ${{ secrets.CI_FIREBASE_DB_REGION }}
      FIREBASE_ADMIN_SA_B64: ${{ secrets.CI_FIREBASE_ADMIN_SA_B64 }}
      RESEND_API_KEY: ${{ secrets.CI_RESEND_API_KEY }}
      RESEND_FROM: no-reply@ci.louhen.app
      RESEND_REPLY_TO: hello@ci.louhen.app
      STATUS_USER: ${{ secrets.CI_STATUS_USER }}
      STATUS_PASS: ${{ secrets.CI_STATUS_PASS }}
      SUPPRESSION_SALT: ${{ secrets.CI_SUPPRESSION_SALT }}
      PW_HEALTH_PATH: /icon.svg
      TEST_E2E_BYPASS_TOKEN: e2e-mocked-token
      PLAYWRIGHT_ARTIFACTS_DIR: artifacts/playwright/e2e
      TS_NODE_PROJECT: tsconfig.e2e.json
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm ci --include=dev

      - name: Report build artifact availability
        run: echo "has_next=${{ needs.build.outputs.has_next }} NEXT_BUILD_DIR=${{ env.NEXT_BUILD_DIR }}"

      - name: Restore Next.js build
        run: rm -rf "${NEXT_BUILD_DIR}"

      - name: Download Next.js build
        if: needs.build.outputs.has_next == 'true'
        uses: actions/download-artifact@v4
        with:
          name: next-build
          path: ${{ env.NEXT_BUILD_DIR }}

      - name: Local build fallback
        if: needs.build.outputs.has_next != 'true'
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          if [ ! -d node_modules ]; then
            npm ci --include=dev
          fi
          npm run build

      - name: Verify Next build directory
        run: |
          echo "NEXT_BUILD_DIR=${NEXT_BUILD_DIR}"
          ls -la "${NEXT_BUILD_DIR}" || true

      - name: Echo Playwright env snapshot
        run: |
          node -e "const snapshot = {}; const pick = (k) => { if (process.env[k] !== undefined) snapshot[k] = process.env[k]; }; ['APP_BASE_URL','BASE_URL','IS_PRELAUNCH','CSP_MODE','TEST_E2E_SHORTCIRCUIT','CSP_NONCE_BYTES','DEFAULT_LOCALE','NEXT_PUBLIC_DEFAULT_LOCALE','NEXT_PUBLIC_ANALYTICS_ENABLED'].forEach(pick); console.log('PLAYWRIGHT_ENV', JSON.stringify(snapshot));"

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Verify environment wiring
        run: |
          required_envs=(NEXT_PUBLIC_ANALYTICS_DISABLED NEXT_PUBLIC_ANALYTICS_DEBUG NEXT_PUBLIC_ENV NEXT_PUBLIC_SITE_URL NEXT_PUBLIC_HCAPTCHA_SITE_KEY NEXT_PUBLIC_WAITLIST_URGENCY NEXT_PUBLIC_COMMIT_SHA NEXT_PUBLIC_LOCALES NEXT_PUBLIC_DEFAULT_LOCALE NEXT_PUBLIC_ALLOW_INDEXING NEXT_PUBLIC_TEST_MODE DEFAULT_LOCALE APP_BASE_URL FIREBASE_PROJECT_ID FIREBASE_DB_REGION FIREBASE_ADMIN_SA_B64 RESEND_API_KEY RESEND_FROM RESEND_REPLY_TO HCAPTCHA_SECRET WAITLIST_CONFIRM_TTL_DAYS STATUS_USER STATUS_PASS SUPPRESSION_SALT EMAIL_TRANSPORT ANALYTICS_STORE_IP IS_PRELAUNCH TEST_MODE TEST_E2E_SHORTCIRCUIT CSP_MODE CSP_NONCE_BYTES ANALYTICS_ENABLED PLAYWRIGHT_BROWSERS_PATH)
          missing=0
          for key in "${required_envs[@]}"; do
            if [ -z "${!key+x}" ]; then
              echo "::error::missing ${key}"
              missing=1
            fi
          done
          if [ "$EMAIL_TRANSPORT" != "noop" ]; then
            echo "::error::EMAIL_TRANSPORT must remain 'noop' in CI (found '${EMAIL_TRANSPORT}')"
            missing=1
          fi
          if [ "$ANALYTICS_STORE_IP" != "false" ]; then
            echo "::error::ANALYTICS_STORE_IP must be 'false' in CI (found '${ANALYTICS_STORE_IP}')"
            missing=1
          fi
          if [ "$NEXT_PUBLIC_ALLOW_INDEXING" = "true" ]; then
            echo "::error::NEXT_PUBLIC_ALLOW_INDEXING must be false in CI"
            missing=1
          fi
          if [ "$NEXT_PUBLIC_ANALYTICS_DISABLED" != "1" ]; then
            echo "::error::NEXT_PUBLIC_ANALYTICS_DISABLED must be '1' in CI (found '${NEXT_PUBLIC_ANALYTICS_DISABLED}')"
            missing=1
          fi
          if [ "$NEXT_PUBLIC_ANALYTICS_DEBUG" != "0" ]; then
            echo "::error::NEXT_PUBLIC_ANALYTICS_DEBUG must be '0' in CI (found '${NEXT_PUBLIC_ANALYTICS_DEBUG}')"
            missing=1
          fi
          if [ "$NEXT_PUBLIC_ENV" != "ci" ]; then
            echo "::error::NEXT_PUBLIC_ENV must be 'ci' during CI runs (found '${NEXT_PUBLIC_ENV}')"
            missing=1
          fi
          if [ "$IS_PRELAUNCH" != "true" ] && [ "$IS_PRELAUNCH" != "1" ]; then
            echo "::error::IS_PRELAUNCH must be enabled in CI (found '${IS_PRELAUNCH}')"
            missing=1
          fi
          if [ "$TEST_MODE" != "1" ]; then
            echo "::error::TEST_MODE must be '1' in CI (found '${TEST_MODE}')"
            missing=1
          fi
          case "${TEST_E2E_SHORTCIRCUIT,,}" in
            1|true)
              ;;
            *)
              echo "::error::TEST_E2E_SHORTCIRCUIT must be truthy (expected '1'); found '${TEST_E2E_SHORTCIRCUIT}'"
              missing=1
              ;;
          esac
          if ! [[ "$CSP_NONCE_BYTES" =~ ^[0-9]+$ ]]; then
            echo "::error::CSP_NONCE_BYTES must be numeric (found '${CSP_NONCE_BYTES}')"
            missing=1
          fi
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Echo Playwright env snapshot
        run: |
          node -e "const snapshot = {}; const pick = (k) => { if (process.env[k] !== undefined) snapshot[k] = process.env[k]; }; ['APP_BASE_URL','BASE_URL','IS_PRELAUNCH','CSP_MODE','TEST_E2E_SHORTCIRCUIT','CSP_NONCE_BYTES','DEFAULT_LOCALE','NEXT_PUBLIC_DEFAULT_LOCALE','NEXT_PUBLIC_ANALYTICS_ENABLED'].forEach(pick); console.log('PLAYWRIGHT_ENV', JSON.stringify(snapshot));"

      - name: Start Next.js server
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          npm run start:e2e > "${NEXT_BUILD_DIR}/test-server.log" 2>&1 &
          echo $! > /tmp/e2e-server.pid

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Wait for app to respond
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          BASE_URL_CLEAN=$(printf '%s' "$BASE_URL" | tr -d '\r\n')
          DEFAULT_LOCALE_CLEAN=$(printf '%s' "$DEFAULT_LOCALE" | tr -d '\r\n')
          BASE_URL_STRIPPED=${BASE_URL_CLEAN%/}
          WAITLIST_URL="${BASE_URL_STRIPPED}/${DEFAULT_LOCALE_CLEAN}/waitlist"
          ROOT_URL="${BASE_URL_STRIPPED}/"
          for i in {1..40}; do
            if curl -sSf "$WAITLIST_URL" >/dev/null 2>&1; then
              echo "Waitlist reachable at $WAITLIST_URL"
              break
            fi
            echo "Waiting for app..."
            sleep 0.5
          done
          curl -sSf "$WAITLIST_URL" >/dev/null || (echo "Waitlist route failed readiness check" && exit 1)
          curl -sSf "$ROOT_URL" >/dev/null || echo "::warning::Root route not ready; continuing because waitlist succeeded."

      - name: Verify test-mode captcha bypass
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          BASE_URL_CLEAN=$(printf '%s' "$BASE_URL" | tr -d '\r\n')
          DEFAULT_LOCALE_CLEAN=$(printf '%s' "$DEFAULT_LOCALE" | tr -d '\r\n')
          BASE_URL_STRIPPED=${BASE_URL_CLEAN%/}
          WAITLIST_URL="${BASE_URL_STRIPPED}/${DEFAULT_LOCALE_CLEAN}/waitlist"
          COUNT=$(curl -s "$WAITLIST_URL" | grep -o 'data-testid="waitlist-form-captcha"' | wc -l)
          echo "Captcha markup count: $COUNT"
          test "$COUNT" -eq 0

      - name: Playwright smoke suite
        if: matrix.csp_mode == 'report-only'
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        env:
          DEBUG: pw:webserver,pw:api
        run: npm run test:e2e:smoke

      - name: Playwright critical suite
        if: matrix.csp_mode == 'report-only'
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        env:
          DEBUG: pw:webserver,pw:api
        run: npm run test:e2e:critical

      - name: Strict CSP smoke suite
        if: matrix.csp_mode == 'strict'
        shell: bash --noprofile --norc -eo pipefail {0}
        env:
          DEBUG: pw:webserver,pw:api
        run: npm run test:e2e:strict-csp

      - name: Collect strict CSP reports
        if: matrix.csp_mode == 'strict'
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          mkdir -p ci-artifacts/csp
          if ! curl -sSf "$BASE_URL/api/security/csp-report" -o ci-artifacts/csp/reports.json; then
            echo '{"reports":[]}' > ci-artifacts/csp/reports.json
          fi

      - name: Upload strict CSP reports
        if: matrix.csp_mode == 'strict'
        uses: actions/upload-artifact@v4
        with:
          name: csp-reports
          path: ci-artifacts/csp/reports.json
          if-no-files-found: warn

      - name: Tail Next.js server log
        if: always()
        run: |
          if [ -f "${NEXT_BUILD_DIR}/test-server.log" ]; then
            echo "Last 300 lines from ${NEXT_BUILD_DIR}/test-server.log"
            tail -n 300 "${NEXT_BUILD_DIR}/test-server.log"
          else
            echo 'No server log found'
          fi

      - name: Upload Playwright HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-html
          path: artifacts/playwright/html
          if-no-files-found: warn

      - name: Upload Playwright traces
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-traces
          path: artifacts/playwright/results/**/trace.zip
          if-no-files-found: warn

      - name: Stop server
        if: always()
        run: kill "$(cat /tmp/e2e-server.pid)" 2>/dev/null || true

  axe:
    name: axe
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 30
    env:
      CI: true
      NODE_ENV: production
      HOST: ${{ vars.HOST }}
      PORT: ${{ vars.PORT }}
      APP_BASE_URL: ${{ vars.BASE_URL }}
      NEXT_PUBLIC_SITE_URL: ${{ vars.BASE_URL }}
      BASE_URL: ${{ vars.BASE_URL }}
      WAITLIST_CONFIRM_TTL_DAYS: '7'
      HCAPTCHA_SECRET: ${{ secrets.CI_HCAPTCHA_SECRET }}
      FIREBASE_PROJECT_ID: ${{ secrets.CI_FIREBASE_PROJECT_ID }}
      FIREBASE_DB_REGION: ${{ secrets.CI_FIREBASE_DB_REGION }}
      FIREBASE_ADMIN_SA_B64: ${{ secrets.CI_FIREBASE_ADMIN_SA_B64 }}
      RESEND_API_KEY: ${{ secrets.CI_RESEND_API_KEY }}
      RESEND_FROM: no-reply@ci.louhen.app
      RESEND_REPLY_TO: hello@ci.louhen.app
      STATUS_USER: ${{ secrets.CI_STATUS_USER }}
      STATUS_PASS: ${{ secrets.CI_STATUS_PASS }}
      SUPPRESSION_SALT: ${{ secrets.CI_SUPPRESSION_SALT }}
      PW_HEALTH_PATH: /icon.svg
      PLAYWRIGHT_ARTIFACTS_DIR: artifacts/playwright/axe
      TS_NODE_PROJECT: tsconfig.e2e.json
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm ci --include=dev

      - name: Report build artifact availability
        run: echo "has_next=${{ needs.build.outputs.has_next }} NEXT_BUILD_DIR=${{ env.NEXT_BUILD_DIR }}"

      - name: Restore Next.js build
        run: rm -rf "${NEXT_BUILD_DIR}"

      - name: Download Next.js build
        if: needs.build.outputs.has_next == 'true'
        uses: actions/download-artifact@v4
        with:
          name: next-build
          path: ${{ env.NEXT_BUILD_DIR }}

      - name: Local build fallback
        if: needs.build.outputs.has_next != 'true'
        run: |
          if [ ! -d node_modules ]; then
            npm ci --include=dev
          fi
          npm run build

      - name: Verify Next build directory
        run: |
          echo "NEXT_BUILD_DIR=${NEXT_BUILD_DIR}"
          ls -la "${NEXT_BUILD_DIR}" || true

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Run accessibility suite (warn)
        id: axe
        continue-on-error: true
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run test:axe

      - name: Tail Next.js server log
        if: always()
        run: |
          if [ -f "${NEXT_BUILD_DIR}/test-server.log" ]; then
            echo "Last 200 lines from ${NEXT_BUILD_DIR}/test-server.log"
            tail -n 200 "${NEXT_BUILD_DIR}/test-server.log"
          else
            echo 'No server log found'
          fi

      - name: Upload accessibility artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-axe
          path: |
            artifacts/playwright
            playwright-report
            test-results
            ${{ env.NEXT_BUILD_DIR }}/test-server.log
          if-no-files-found: warn

      - name: Flag accessibility failures
        if: steps.axe.outcome == 'failure'
        run: echo "::warning::Accessibility sweep reported issues. Review the uploaded artifacts."

  quarantine:
    name: quarantine (non-blocking)
    runs-on: ubuntu-latest
    needs: build
    continue-on-error: true
    timeout-minutes: 25
    env:
      CI: true
      NODE_ENV: production
      HOST: ${{ vars.HOST }}
      PORT: ${{ vars.PORT }}
      APP_BASE_URL: ${{ vars.BASE_URL }}
      NEXT_PUBLIC_SITE_URL: ${{ vars.BASE_URL }}
      BASE_URL: ${{ vars.BASE_URL }}
      WAITLIST_CONFIRM_TTL_DAYS: '7'
      HCAPTCHA_SECRET: ${{ secrets.CI_HCAPTCHA_SECRET }}
      FIREBASE_PROJECT_ID: ${{ secrets.CI_FIREBASE_PROJECT_ID }}
      FIREBASE_DB_REGION: ${{ secrets.CI_FIREBASE_DB_REGION }}
      FIREBASE_ADMIN_SA_B64: ${{ secrets.CI_FIREBASE_ADMIN_SA_B64 }}
      RESEND_API_KEY: ${{ secrets.CI_RESEND_API_KEY }}
      RESEND_FROM: no-reply@ci.louhen.app
      RESEND_REPLY_TO: hello@ci.louhen.app
      STATUS_USER: ${{ secrets.CI_STATUS_USER }}
      STATUS_PASS: ${{ secrets.CI_STATUS_PASS }}
      SUPPRESSION_SALT: ${{ secrets.CI_SUPPRESSION_SALT }}
      PW_HEALTH_PATH: /icon.svg
      PLAYWRIGHT_ARTIFACTS_DIR: artifacts/playwright/quarantine
      TS_NODE_PROJECT: tsconfig.e2e.json
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm ci --include=dev

      - name: Restore Next.js build
        run: rm -rf "${NEXT_BUILD_DIR}"

      - name: Download Next.js build
        if: needs.build.outputs.has_next == 'true'
        uses: actions/download-artifact@v4
        with:
          name: next-build
          path: ${{ env.NEXT_BUILD_DIR }}

      - name: Local build fallback
        if: needs.build.outputs.has_next != 'true'
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          if [ ! -d node_modules ]; then
            npm ci --include=dev
          fi
          npm run build

      - name: Detect quarantine specs
        id: quarantine
        run: |
          if ls tests/_quarantine/**/*.ts 1>/dev/null 2>&1 || ls tests/_quarantine/**/*.tsx 1>/dev/null 2>&1; then
            echo "found=true" >> "$GITHUB_OUTPUT"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Cache Playwright browsers
        if: steps.quarantine.outputs.found == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Install Playwright browsers
        if: steps.quarantine.outputs.found == 'true'
        run: npx playwright install --with-deps chromium

      - name: Run quarantine suite (non-blocking)
        if: steps.quarantine.outputs.found == 'true'
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        env:
          DEBUG: pw:webserver,pw:api
        run: npx playwright test tests/_quarantine --project=desktop-chromium --workers=1

      - name: Upload quarantine artifacts
        if: always() && steps.quarantine.outputs.found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: playwright-quarantine
          path: |
            artifacts/playwright
            playwright-report
            ${{ env.NEXT_BUILD_DIR }}/test-server.log
          if-no-files-found: warn

  lighthouse:
    name: lighthouse
    runs-on: ubuntu-latest
    needs: build
    timeout-minutes: 30
    env:
      CI: true
      NODE_ENV: production
      BASE_URL: ${{ vars.BASE_URL }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm ci --include=dev

      - name: Report build artifact availability
        run: echo "has_next=${{ needs.build.outputs.has_next }} NEXT_BUILD_DIR=${{ env.NEXT_BUILD_DIR }}"

      - name: Restore Next.js build
        run: rm -rf "${NEXT_BUILD_DIR}"

      - name: Download Next.js build
        if: needs.build.outputs.has_next == 'true'
        uses: actions/download-artifact@v4
        with:
          name: next-build
          path: ${{ env.NEXT_BUILD_DIR }}

      - name: Local build fallback
        if: needs.build.outputs.has_next != 'true'
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          if [ ! -d node_modules ]; then
            npm ci --include=dev
          fi
          npm run build

      - name: Verify Next build directory
        run: |
          echo "NEXT_BUILD_DIR=${NEXT_BUILD_DIR}"
          ls -la "${NEXT_BUILD_DIR}" || true

      - name: Run Lighthouse (warn)
        id: lhci
        continue-on-error: true
        # prevent Homebrew profile sourcing in CI
        shell: bash --noprofile --norc -eo pipefail {0}
        run: npm run lighthouse

      - name: Upload Lighthouse artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-report
          path: |
            artifacts/lighthouse
            ${{ env.NEXT_BUILD_DIR }}/test-server.log
          if-no-files-found: warn

      - name: Flag Lighthouse regressions
        if: steps.lhci.outcome == 'failure'
        run: echo "::warning::Lighthouse budgets failed. Review the lighthouse-report artifact."

  sbom:
    name: sbom
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --include=dev

      - name: Generate CycloneDX SBOM
        run: |
          mkdir -p artifacts/sbom
          npm sbom --sbom-format=cyclonedx > artifacts/sbom/cyclonedx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: artifacts/sbom/cyclonedx.json
          if-no-files-found: error

  policy-guards:
    name: policy-guards
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --include=dev

      - name: Build design tokens
        run: npm run -w @louhen/design-tokens build

      - name: Color policy scan (warn)
        run: |
          if ! COLOR_POLICY_MODE=warn npm run guard:hex; then
            echo "::warning::Color policy quick scan reported matches."
          fi

      - name: Color policy enforce (warn)
        run: |
          if ! COLOR_POLICY_MODE=enforce npm run ci:color-policy; then
            echo "::warning::Color policy guard found violations. Review the color-policy-report artifact."
          fi

      - name: Upload color policy report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: color-policy-report
          path: ci-artifacts/color-policy-report.txt
          if-no-files-found: warn

      - name: Inline script and CSP guard (warn)
        run: |
          node <<'NODE'
          const { execSync } = require('node:child_process');
          const { readFileSync } = require('node:fs');

          const files = execSync('git ls-files', { encoding: 'utf8' })
            .split('\n')
            .map((line) => line.trim())
            .filter((line) => line.length > 0 && /\.(tsx|ts|jsx|js)$/.test(line));

          const warnings = [];
          const inlinePattern = /<script[\s>]/i;
          const dangerousPattern = /dangerouslySetInnerHTML/;

          for (const file of files) {
            const content = readFileSync(file, 'utf8');
            const lines = content.split(/\r?\n/);
            lines.forEach((line, index) => {
              if (inlinePattern.test(line)) {
                warnings.push(`inline-script:${file}:${index + 1}: ${line.trim()}`);
              }
              if (dangerousPattern.test(line)) {
                warnings.push(`dangerous-html:${file}:${index + 1}: ${line.trim()}`);
              }
            });
          }

          if (warnings.length) {
            for (const entry of warnings) {
              console.log(`::warning::${entry}`);
            }
          } else {
            console.log('No inline <script> or dangerouslySetInnerHTML usage detected.');
          }
          NODE

      - name: Forbidden paths guard (warn)
        run: |
          node <<'NODE'
          const { execSync } = require('node:child_process');

          const checks = [
            {
              cmd: "git ls-files -- 'public/**/*.js'",
              message: 'JavaScript under public/ ships outside CSP. Prefer bundling through Next.js.',
            },
            {
              cmd: "git ls-files -- 'public/**/*.html'",
              message: 'Raw HTML under public/ can bypass inline script protections.',
            },
          ];

          for (const { cmd, message } of checks) {
            let output = '';
            try {
              output = execSync(cmd, { encoding: 'utf8', stdio: ['ignore', 'pipe', 'ignore'] });
            } catch (error) {
              if (error.status && error.status !== 0) {
                throw error;
              }
            }
            const files = output.split('\n').map((line) => line.trim()).filter(Boolean);
            for (const file of files) {
              console.log(`::warning::forbidden-path:${file}: ${message}`);
            }
          }
          NODE

      - name: Prefixless marketing guard
        run: npm run guard:prefixless

      - name: Secret hygiene guard (warn)
        run: |
          node <<'NODE'
          const { readdirSync, statSync, readFileSync } = require('node:fs');
          const { join, relative } = require('node:path');

          const buildDir = process.env.NEXT_BUILD_DIR || '.next';
          const ignoreDirs = new Set(['.git', 'node_modules', buildDir, 'tmp', 'artifacts', 'ci-artifacts', 'playwright-report', 'lighthouse-report']);
          const allowFiles = new Set(['.env.example']);
          const suspicious = [];
          const pattern = /(api[_-]?key|secret|token|password)[^=:\n]{0,40}[:=]\s*(['"]?)([A-Za-z0-9][_A-Za-z0-9\-]{16,})\2/gi;
          const allowedHints = [/dummy/i, /test/i, /example/i, /sample/i, /ci[-_]?/, /dev/i, /local/i, /^0x0+$/i, /louhen/i, /status-ops/i, /status-secret/i];

          function shouldSkipValue(value) {
            return allowedHints.some((regex) => regex.test(value));
          }

          function walk(dir) {
            for (const entry of readdirSync(dir)) {
              const full = join(dir, entry);
              const rel = relative(process.cwd(), full);
              if (rel.startsWith('.git/')) continue;
              const stat = statSync(full);
              if (stat.isDirectory()) {
                if (ignoreDirs.has(entry)) continue;
                walk(full);
              } else if (stat.isFile()) {
                if (allowFiles.has(rel)) continue;
                if (/\.(png|jpg|jpeg|webp|gif|ico|icns|woff2?|ttf|otf|wasm|lock|zip|tar|gz|svg)$/i.test(entry)) continue;
                const content = readFileSync(full, 'utf8');
                const lines = content.split(/\r?\n/);
                lines.forEach((line, index) => {
                  let match;
                  while ((match = pattern.exec(line)) !== null) {
                    const value = match[3];
                    if (!shouldSkipValue(value)) {
                      suspicious.push(`${rel}:${index + 1}: ${line.trim()}`);
                    }
                  }
                });
              }
            }
          }

          walk(process.cwd());

          if (suspicious.length) {
            for (const entry of suspicious) {
              console.log(`::warning::potential-secret:${entry}`);
            }
          } else {
            console.log('Secret hygiene guard passed - no high-risk patterns found.');
          }
          NODE

      - name: Release checklist status (warn)
        if: github.event_name == 'pull_request'
        run: |
          if [ ! -f PRELAUNCH_CHECKLIST.md ]; then
            echo "::warning::PRELAUNCH_CHECKLIST.md not found. Ensure release readiness is tracked."
            exit 0
          fi
          if grep -q '\- \[ \]' PRELAUNCH_CHECKLIST.md; then
            echo "::warning::PRELAUNCH_CHECKLIST.md has unchecked items."
          else
            echo 'Prelaunch checklist complete.'
          fi

      - name: CI safety toggles (warn)
        run: |
          if grep -n "EMAIL_TRANSPORT: *['\"]\?resend" .github/workflows/ci.yml; then
            echo "::warning::EMAIL_TRANSPORT should remain noop inside ci.yml."
          fi
          if grep -n "NEXT_PUBLIC_ALLOW_INDEXING: *['\"]\?true" .github/workflows/ci.yml; then
            echo "::warning::NEXT_PUBLIC_ALLOW_INDEXING must stay false for CI builds."
          fi

      - name: Require staging source for production PRs
        if: github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'production'
        run: |
          if [ "${{ github.event.pull_request.head.ref }}" != "staging" ]; then
            echo "::error::PRs targeting production must originate from staging."
            exit 1
          fi
          echo 'Release guard passed.'
